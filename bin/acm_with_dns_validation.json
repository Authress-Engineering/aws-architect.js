"CreateAndReturnAcmCertificateArnRole": {
    "Type": "AWS::IAM::Role",
    "Properties": {
    "AssumeRolePolicyDocument": {
        "Version": "2012-10-17",
        "Statement": [{
        "Effect": "Allow",
        "Principal": {
            "Service": ["lambda.amazonaws.com"]
        },
        "Action": ["sts:AssumeRole"]
        }]
    },
    "ManagedPolicyArns": [
        "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole",
        "arn:aws:iam::aws:policy/AWSCertificateManagerFullAccess"
    ]
    }
},
"CreateAndReturnAcmCertificateArnLambdaFunction": {
    "Type": "AWS::Lambda::Function",
    "Properties": {
    "Code": {
        "ZipFile": {
        "Fn::Join": [ "\n", [
            "// http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html",
            "const aws = require('aws-sdk');"
            "const cloudFormationResponseHandler = require('cfn-response');",
            "let acmClient = new aws.ACM();",
            "exports.handler = function(event, context) {",
            "  let domainName = event.ResourceProperties.DomainName;",
            "  if (event.RequestType === 'Delete') {",
            "    acmClient.listCertificates({}).promise()",
            "      .then(certs => {",
            "        let foundCert = certs.CertificateSummaryList.find(cert => cert.DomainName === domainName);",
            "        if (foundCert) {",
            "          return acmClient.deleteCertificate({ CertificateArn: foundCert.CertificateArn }).promise();",
            "        }",
            "        return null;",
            "      })",
            "      .then(() => {",
            "        return cloudFormationResponseHandler.send(event, context, cloudFormationResponseHandler.SUCCESS);",
            "      })",
            "      .catch(error => {",
            "        return cloudFormationResponseHandler.send(event, context, cloudFormationResponseHandler.FAILED, { title: 'Failed to delete Certificate', error: error });",
            "      });",
            "  }",
            "  ",
            "  if (event.RequestType !== 'Create') {",
            "    cloudFormationResponseHandler.send(event, context, cloudFormationResponseHandler.SUCCESS);",
            "  }",
            "  ",
            "  acmClient.requestCertificate({ DomainName: domainName, SubjectAlternativeNames: [`*.${domainName}`], ValidationMethod: 'DNS' }).promise()",
            "    .then(data => {",
            "      return new Promise(resolve => setTimeout(resolve, 10000))",
            "        .then(() => {",
            "          return acmClient.describeCertificate({ CertificateArn: data.CertificateArn }).promise()",
            "            .then(validationData => {",
            "              let response = {",
            "                CertificateArn: data.CertificateArn,",
            "                VerificationRecordMainName: validationData.Certificate.DomainValidationOptions[0].ResourceRecord.Name,",
            "                VerificationRecordMainValue: validationData.Certificate.DomainValidationOptions[0].ResourceRecord.Value,",
            "                VerificationRecordAlternativeName: validationData.Certificate.DomainValidationOptions[1].ResourceRecord.Name,",
            "                VerificationRecordAlternativeValue: validationData.Certificate.DomainValidationOptions[1].ResourceRecord.Value",
            "              };",
            "              return cloudFormationResponseHandler.send(event, context, cloudFormationResponseHandler.SUCCESS, response);",
            "            });",
            "        });",
            "    })",
            "    .catch(error => {",
            "      return cloudFormationResponseHandler.send(event, context, cloudFormationResponseHandler.FAILED, { title: 'Failed to created Certificate', error: error });",
            "    });",
            "}"
        ]]
        }
    },
    "Handler": "index.handler",
    "Runtime": "nodejs8.10",
    "Timeout": "30",
    "Role": { "Fn::GetAtt": [ "CreateAndReturnAcmCertificateArnRole", "Arn" ] }
    }
},
"AcmCertificate": {
    "Type": "Custom::LambdaCallout",
    "Properties": {
    "ServiceToken": { "Fn::GetAtt": [ "CreateAndReturnAcmCertificateArnLambdaFunction", "Arn" ] },
    "DomainName": { "Ref": "hostedName" }
    }
},
"AcmCertificateValidationForMain": {
    "Type": "AWS::Route53::RecordSet",
    "Properties": {
    "HostedZoneName": {
        "Fn::Join": [
        "",
        [
            {
            "Ref": "hostedName"
            },
            "."
        ]
        ]
    },
    "Comment": {
        "Fn::Join": [
        "",
        [
            "Created for service",
            { "Ref": "serviceName" }
        ]
        ]
    },
    "Name": { "Fn::GetAtt": [ "AcmCertificate", "VerificationRecordMainName" ] },
    "ResourceRecords": [{ "Fn::GetAtt": [ "AcmCertificate", "VerificationRecordMainValue" ] }],
    "Type": "CNAME"
    }
},
"AcmCertificateValidationForAlternate": {
    "Type": "AWS::Route53::RecordSet",
    "Properties": {
    "HostedZoneName": {
        "Fn::Join": [
        "",
        [
            {
            "Ref": "hostedName"
            },
            "."
        ]
        ]
    },
    "Comment": {
        "Fn::Join": [
        "",
        [
            "Created for service",
            { "Ref": "serviceName" }
        ]
        ]
    },
    "Name": { "Fn::GetAtt": [ "AcmCertificate", "VerificationRecordAlternativeName" ] },
    "ResourceRecords": [{ "Fn::GetAtt": [ "AcmCertificate", "VerificationRecordAlternateValue" ] }],
    "Type": "CNAME"
    }
}